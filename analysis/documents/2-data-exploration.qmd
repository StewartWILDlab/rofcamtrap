---
title: "Data Exploration and Correction"
author:
  - name: Valentin Lucet
    email: valentin.lucet@gmail.com
    orcid: 0000-0003-0268-818X
    affiliation: 
      - ref: wlu
affiliations:
  - id: wlu
    name: Wilfrid Laurier University
title-block-published: "Last updated"  
date: now
date-format: long
format:
  html: default
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    extra_dependencies: ["float"]
format-links: false
execute:
  echo: true
  warning: false
  message: false
  comment: "#>"
  fig-dpi: 600
# bibliography: references.bib
---

## Introduction

In this exploration of the data, we will loosely follow the protocol in "[Introduction to Camera Trap Data Management and Analysis in R](https://wildcolab.github.io/Introduction-to-Camera-Trap-Data-Management-and-Analysis-in-R/index.html)", hereafter referred to as ICTDMA.

```{r, include=FALSE}
knitr::opts_chunk$set(fig.pos = "H", out.extra = "")
backup_options <- options()
options(scipen = 1, digits = 2)
source("functions.R")
```

### Data loading and conversion

We load the annotation data and convert it into the proper format, which is the "Wildlife Insights" format. As described in ICTDMA:

" Their standard format is composed of four different elements:

-   Project data: a dataframe containing key information about the project itself, e.g. how the cameras were deployed and what the target features were.

-   Image data: a dataframe containing all of the information contained within each image. This information is typically added by humans, but increasing we are using artificial intelligence to speed up this process.

-   Deployment data: a dataframe listing the activity of the camera traps involved in your study, and any issues encountered during deployments which may influence their analysis

-   Camera data: a dataframe all the cameras deployed in the project "

Ideally, we would use the CamtrapDP format, but we shall circle back to that in the future.

#### Project data

We will let that aside for the moment as it is not relevant to the specific task as hand, but here are the fields this data format expects:

```{r, eval=FALSE}
#| label: project
[1] "project_id"                          "project_name"                        "project_short_name"                 
[4] "project_objectives"                  "project_species"                     "project_species_individual"         
[7] "project_sensor_layout"               "project_sensor_layout_targeted_type" "project_bait_use"                   
[10] "project_bait_type"                   "project_stratification"              "project_stratification_type"        
[13] "project_sensor_method"               "project_individual_animals"          "project_blank_images"               
[16] "project_sensor_cluster"              "project_admin"                       "project_admin_email"                
[19] "project_admin_organization"          "country_code"                        "embargo"                            
[22] "initiative_id"                       "metadata_license"                    "image_license"                      
[25] "data_citation"                       "count_optional"                      "project_type
```

#### Image data

The image data is the annotations data, which we load:

```{r}
#| label: image
image_data <- readRDS(here::here("data", "objects", "annotations_animals.rds")) |> 
  dplyr::select(id, source_file_with_dep,
                image_id, species:comment, camera_id,
                maker_notes_sequence:maker_notes_user_label, plot_id:ymd) |> 
  dplyr::mutate(site_id = sapply(image_id, \(x) strsplit(x, "_")[[1]][1]),
                date_time = lubridate::as_date(date_time)) |> 
  dplyr::rename(file_path = source_file_with_dep) |> 
  dplyr::filter(!is.na(date_time))

# Fixing error 
# TODO make it more explicit
# image_data[image_data$date_time==max(image_data$date_time, na.rm = T),] |> View()
# image_data[image_data$ymd=="2024_Aug_19",]$date_time <- lubridate::as_date("2022-08-19")
# image_data[image_data$ymd=="2024_Aug_19",]$ymd <- "2022_Aug_19"

head(image_data)
```

#### Camera and deployment data

The camera and deployment data are currently together as each camera was only deployed once

```{r}
#| label: camdep
cam_dep_data <- readRDS(here::here("data", "objects", "cams_sf_coords.rds")) |> 
  sf::st_drop_geometry() |> 
  dplyr::select(dplyr::ends_with("_id"), date_deployed, date_retrieved, longitude, latitude) |> 
  dplyr::mutate(date_deployed = lubridate::as_date(date_deployed),
                date_retrieved = lubridate::as_date(date_retrieved)) 
stopifnot(sum(table(cam_dep_data$camera_id) != 1) == 0)
```

#### Deployment plot

Cameras, Sorted by deployment date, with associated site labelled.

```{r, eval: FALSE fig.height=35, fig.width=7}
#| fig.width: 8
#| fig.height: 35

cam_dep_data_with_status <- cam_dep_data |>
  dplyr::mutate(status = ifelse(date_deployed < date_retrieved, "valid", "invalid")) |>
  dplyr::mutate(status = ifelse(is.na(status), "invalid", status))

cam_dep_data_with_status |>
  ggplot2::ggplot(ggplot2::aes(x = date_deployed, y = reorder(camera_id,
                                                              date_deployed,
                                                              decreasing = TRUE))) +
  ggplot2::geom_segment(ggplot2::aes(xend = date_retrieved, yend = camera_id,
                                     color = status), alpha = 0.15, linewidth = 3) +
  ggplot2::geom_point(ggplot2::aes(x = date_deployed, y = camera_id,
                                   color = status)) +
  ggplot2::geom_point(ggplot2::aes(x = date_retrieved, y = camera_id,
                                   color = status)) +

  ggplot2::geom_point(data = image_data,
                      ggplot2::aes(x = date_time, y = camera_id),
                      color = "firebrick", size = 0.5) +

  ggplot2::geom_text(ggplot2::aes(x = date_deployed-60, y = camera_id,
                                  label = site_id,
                                  color = status), size = 3) +
  ggplot2::scale_color_discrete(type = c("#E69F00","#56B4E9")) +
  ggplot2::theme_bw()
```

#### Adjust for daylight savings

November 6th 2022 to March 12th 2023 

November 5th 2023 to March 10th 2024

#### Compare platform

```{r}
wt <- readRDS("../../my_report.rds")
```


```{r}
image_data |> dplyr::filter(plot_id == "P045") |> dplyr::filter(grepl(.data$file_path, pattern = "TrailCamStorage_2/", fixed = T)) |> dplyr::select(image_id, species) |> unique() |> dplyr::pull(species) |> table() |> sort()

wt |> dplyr::filter(grepl(.data$location, pattern = "TC2_P045", fixed = T)) |> dplyr::select(image_id, species_common_name) |> unique() |> dplyr::pull(species_common_name) |> table() |> sort()
```

```{r}
image_data |> dplyr::filter(plot_id == "P045") |> dplyr::filter(grepl(.data$file_path, pattern = "TrailCamStorage/", fixed = T)) |> dplyr::select(image_id, species) |> unique() |> dplyr::pull(species) |> table() |> sort()

wt |> dplyr::filter(grepl(.data$location, pattern = "TC1_P045", fixed = T)) |> dplyr::select(image_id, species_common_name) |> unique() |> dplyr::pull(species_common_name) |> table() |> sort()
```

```{r}
image_data |> dplyr::filter(plot_id == "P080") |> dplyr::filter(grepl(.data$file_path, pattern = "TrailCamStorage/", fixed = T)) |> dplyr::select(image_id, species) |> unique() |> dplyr::pull(species) |> table() |> sort()

wt |> dplyr::filter(grepl(.data$location, pattern = "TC1_P080", fixed = T)) |> dplyr::select(image_id, species_common_name) |> unique() |> dplyr::pull(species_common_name) |> table() |> sort()
```

#### AI results explore

```{r}
library(tidyverse)

labels <- read.csv("../../3_Classifiers/1_species_classifier/labels.csv") |> 
  pivot_longer(OtherBird:Bear, names_to = "Category_true", values_to = "val") |> 
  filter(val != 0) |> select(-val)
preds <- read.csv("../../3_Classifiers/1_species_classifier/predictions.csv") |> 
  pivot_longer(!X, names_to = "Category_pred", values_to = "conf") |> 
  group_by(X) |> 
  arrange(desc(conf)) |> 
  slice(1) |> ungroup()

joined <- labels |> 
  left_join(preds, by=c("id"="X")) |> 
  drop_na() |> 
  mutate(correct = Category_true == Category_pred)

errors <- joined |> filter(!correct)
```

```{r}
ex <- errors |> filter(Category_true == "Moose", Category_pred == "Caribou") |> 
  pull(filepath) |> 
  str_replace("/media/vlucet/TrailCamST/", "/media/vlucet/TrailCamST1/_old/")

for (thefile in ex) {
  # print(file.path("/media/vlucet/TrailCamST1/_old/errors_ex", basename(thefile)))
  file.copy(thefile, file.path("/media/vlucet/TrailCamST1/_old/errors_ex/", basename(thefile)))
}
```

